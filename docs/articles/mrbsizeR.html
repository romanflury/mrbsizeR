<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
<code>mrbsizeR</code>: Scale space multiresolution analysis in R • mrbsizeR</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="&lt;code&gt;mrbsizeR&lt;/code&gt;: Scale space multiresolution analysis in R">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-118890730-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118890730-1');
</script>
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">mrbsizeR</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">1.1.2.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="../articles/mrbsizeR.html">Vignette</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/romanflury/mrbsizeR">
    <span class="fa fa-lg fa-github"></span>
     
    github
  </a>
</li>
<li>
  <a href="http://twitter.com/fluryro">
    <span class="fa fa-lg fa-twitter"></span>
     
    twitter
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>
<code>mrbsizeR</code>: Scale space multiresolution analysis in R</h1>
                        <h4 class="author">Thimo Schuster, Roman Flury</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/romanflury/mrbsizeR/blob/master/vignettes/mrbsizeR.Rmd"><code>vignettes/mrbsizeR.Rmd</code></a></small>
      <div class="hidden name"><code>mrbsizeR.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p><code>mrbsizeR</code> is an <strong>R</strong> package based on the MRBSiZer method by <span class="citation">Holmström et al. (2011)</span>. The name is an abbreviation for <strong>M</strong>ulti<strong>R</strong>esolution <strong>B</strong>ayesian <strong>SI</strong>gnificant <strong>ZE</strong>ro crossings of derivatives in <strong>R</strong> and the method extends the portfolio of Bayesian SiZer methods for images and spatial fields, originally introduced by <span class="citation">Erästö and Holmström (2005)</span>.</p>
<p>In the analysis of spatial fields or images (i.e. an object), scale space methods are often useful. When observed on different scales, distinct features of the object can be detected. Imagine the concept of a branch of a tree (<span class="citation">Lindeberg (1994)</span>): This concept makes sense on a scale from a few centimeters to a few meters. On a much smaller scale, one could describe the molecules that form the branch and on a much larger scale, it would be possible to describe the forest the tree grows in. The goal in scale space analysis is therefore to represent an object on different scales, and this is done by dividing it into a family of smooths. The smooths are made on different smoothing levels and each smooth provides information relevant at a particular scale, which makes it possible to extract scale-dependent features from the object.</p>
<p>Significant Zero Crossings of Derivatives (SiZer) is a method based on scale space ideas and has originally been developed for smooths of curves and time series. The goal is to find out whether a certain feature of the curve is “really there” or if it is just a sampling artifact. For curves and time series this is usually done by investigating the significance of the increases and decreases of the derivatives. Within the last years, this concept has been extended to various directions.</p>
<p>In contrast to usual scale space procedures, where a wide range of smooths is used, <code>mrbsizeR</code> employs differences of smooths at neighboring scales. This attempts to separate the features into distinct scale categories more aggressively. In a next step, the resulting differences are investigated with a Bayesian version of SiZer to see which of the features found are “really there” and which are only artifacts of sampling.</p>
For data on a regular grid, one can summarize the analysis procedure in three steps:

<p>For spherical data, no Bayesian signal reconstruction is implemented. The analysis procedure for this type of data therefore consists of the forming of scale-dependent details and the subsequent credibility analysis. The single steps and their application in <code>mrbsizeR</code> are explained by the following three examples. For further theory and algorithm details, see <span class="citation">Holmström et al. (2011)</span> and <span class="citation">Schuster (2017)</span>. An extensive review of different statistical scale space methods including their applications is available in <span class="citation">Holmström and Pasanen (2016)</span>.</p>
</div>
<div id="example-data-on-a-regular-grid" class="section level1">
<h1 class="hasAnchor">
<a href="#example-data-on-a-regular-grid" class="anchor"></a>Example: Data On A Regular Grid</h1>
<p>For the first example, data from the North American Regional Climate Change Assessment Program (NARCCAP) is analyzed. NARCCAP is an international program producing climate change simulations for Canada, the United States and northern Mexico. The data used for this example is based on the MM5I regional model  and is a simulation of the surface air temperature during summer 1995 , see also <a href="http://www2.mmm.ucar.edu/mm5/" class="uri">http://www2.mmm.ucar.edu/mm5/</a> and <a href="http://www.narccap.ucar.edu/index.html" class="uri">http://www.narccap.ucar.edu/index.html</a>. The simulation was carried out on a 120-by-98 regular grid, therefore 11’760 data points are available in total. The data set is not part of the <code>mrbsizeR</code> package.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Structure of the dataset </span>
<span class="kw">str</span>(tas.su.<span class="fl">1995.</span>MM5I)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ lon: num [1:120, 1:98] 241 241 242 242 242 ...</span>
<span class="co">#&gt;  $ lat: num [1:120, 1:98] 23 23.1 23.2 23.3 23.5 ...</span>
<span class="co">#&gt;  $ su : num [1:120, 1:98] 21.8 21.7 21.7 21.7 21.7 ...</span></code></pre></div>
<p> </p>
<p>The variables <code>lon</code> and <code>lat</code> describe the longitude and latitude of each simulated surface air temperature in summer 1995 in degrees Celsius (<code>su</code>). The data covers the United States, the southern part of Canada and the northern part of Mexico.</p>
<div class="figure" style="text-align: center">
<img src="mrbsizeR_files/figure-html/plotdata-1.png" alt="\label{fig:plotdata}Simulated surface air temperature in summer 1995 for the United States, the southern part of Canada and the northern part of Mexico. The unit of the temperature is degrees Celsius." width="480"><p class="caption">
Simulated surface air temperature in summer 1995 for the United States, the southern part of Canada and the northern part of Mexico. The unit of the temperature is degrees Celsius.
</p>
</div>
<p>As the output of the <code>mrbsizeR</code> analysis are plots on a rectangular grid, it makes sense to display Figure  also like this (compare Figure ). By combining Figures  and , it is still possible to recognize all the important features such as coastlines, the Baja California or the Great Lakes.</p>
<div class="figure" style="text-align: center">
<img src="mrbsizeR_files/figure-html/recdata-1.png" alt="\label{fig:recdata}Simulated surface air temperature in summer 1995 for the United States, the southern part of Canada and the northern part of Mexico on a rectangular grid. Red describes warmer areas, colder areas are colored blue." width="576"><p class="caption">
Simulated surface air temperature in summer 1995 for the United States, the southern part of Canada and the northern part of Mexico on a rectangular grid. Red describes warmer areas, colder areas are colored blue.
</p>
</div>

<div id="bayesian-signal-reconstruction" class="section level2">
<h2 class="hasAnchor">
<a href="#bayesian-signal-reconstruction" class="anchor"></a>Bayesian Signal Reconstruction</h2>
<p>The first step of the <code>mrbsizeR</code> analysis is the Bayesian signal reconstruction. The data set is assumed to be a random signal which might be noisy. In order to account for this uncertainty in the data, a Bayesian model is used to reconstruct the original signal. The model used is <span class="math display">\[\boldsymbol{y} = \boldsymbol{x} + \boldsymbol{\varepsilon},\]</span> where <span class="math inline">\(\boldsymbol{y}\)</span> is the observed random signal (compare Figures  and ), <span class="math inline">\(\boldsymbol{x}\)</span> is the unobserved underlying original signal and <span class="math inline">\(\boldsymbol{\epsilon}\)</span> is the noise. A <span class="math inline">\(\mathcal{N}\)</span>-Inv-<span class="math inline">\(\chi^{2}\)</span> prior distribution is assumed. In <code>mrbsizeR</code>, not the full posterior <span class="math inline">\(p(\boldsymbol{x}, \sigma^{2}|\boldsymbol{y})\)</span> is of interest, but the marginal posterior <span class="math inline">\(p(\boldsymbol{x}|\boldsymbol{y})\)</span>. This marginal posterior follows a multivariate <span class="math inline">\(t\)</span>-distribution <span class="math inline">\(t_{\nu}\)</span> and sampling from it results in samples from the reconstructed original signal <span class="math inline">\(\boldsymbol{x}\)</span>.</p>
<p>Depending on how much is known about the noise in <span class="math inline">\(\boldsymbol{y}\)</span>, the prior distribution parameters can be adjusted. For the example of the surface air temperature, the parameters <span class="math inline">\(\lambda_{0} = 0.2\)</span>, <span class="math inline">\(\nu_{0} = 15\)</span> and <span class="math inline">\(\sigma_{0}^{2} = 36^2\)</span> were used. This prior has little influence on the posterior as no information about possible noise on <span class="math inline">\(\boldsymbol{y}\)</span> is available. Using the function <code><a href="../reference/rmvtDCT.html">rmvtDCT()</a></code>, samples from a <span class="math inline">\(t_{\nu}\)</span>-distribution can be generated. The sampling algorithm uses a discrete cosine transform (DCT) to speed up computations. For further information on the distributions and the sampling algorithm, see <span class="citation">Holmström et al. (2011)</span> and <span class="citation">Schuster (2017)</span>.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Sampling from a multivariate t-distribution</span>
tas.post.samp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rmvtDCT.html">rmvtDCT</a></span>(<span class="dt">object =</span> tas.su.<span class="fl">1995.</span>MM5I<span class="op">$</span>su, 
                         <span class="dt">lambda =</span> <span class="fl">0.2</span>, <span class="dt">sigma =</span> <span class="dv">36</span>, <span class="dt">nu0 =</span> <span class="dv">15</span>, <span class="dt">ns =</span> <span class="dv">1000</span>)</code></pre></div>
<p> </p>
<p>1000 samples of the posterior distribution of the surface air temperature in Canada, Mexico and the United States were generated. These samples now form the reconstructed signal <span class="math inline">\(\boldsymbol{x}\)</span> and are used for further analysis.</p>
</div>
<div id="forming-of-scale-dependent-detail-components" class="section level2">
<h2 class="hasAnchor">
<a href="#forming-of-scale-dependent-detail-components" class="anchor"></a>Forming of scale-dependent detail components</h2>
<p>Now that the original signal has been reconstructed, one can start forming scale-depending detail components. For being able to create differences of smooths at neighboring scales <span class="math inline">\(\boldsymbol{z}_{1}, \dots, \boldsymbol{z}_{L}\)</span>, a set of appropriate smoothing levels <span class="math inline">\(\lambda_{1}, \dots, \lambda_{L}\)</span> needs to be known. In contrast to other scale space methods, where a wide range of smoothing levels is used, <code>mrbsizeR</code> only requires a few of them. The goal is to separate the features of the object (here: the surface air temperature data) into scale-distinct categories. If too many smoothing levels are chosen, this will result in categories that do not feature relevant detail components. If, on the other hand, too few smoothing levels are chosen, detail components on different scales might mix up and are not recognizable anymore. It is therefore not only crucial to determine which smoothing levels are useful, but also the number of smoothing levels that should be used.</p>
<p>All methods proposed for the selection of smoothing levels have one thing in common: They offer a good starting point for finding useful smoothing levels - but to make sure that all detail components are captured optimally, user interaction is usually inevitable. Typically, a few iterations are necessary until satisfying smoothing levels are found.</p>
<p>The first method for the smoothing level selection depends on the smoother implemented in <code>mrbsizeR</code> and the dimension of the object analyzed only. By plotting so-called tapering functions of the eigenvalues of <span class="math inline">\(\boldsymbol{Q}\)</span>, a precision matrix used in the smoother of <code>mrbsizeR</code>, and the smoothing levels <span class="math inline">\(\lambda_{i}\)</span>, it is possible to determine which <span class="math inline">\(\lambda\)</span>’s could be useful. The eigenvalues and the smoothing parameters are related as follows:</p>
<ul>
<li>Small <span class="math inline">\(\lambda\)</span>’s involve large eigenvalues of <span class="math inline">\(\boldsymbol{Q}\)</span>.</li>
<li>Large <span class="math inline">\(\lambda\)</span>’s involve small eigenvalues of <span class="math inline">\(\boldsymbol{Q}\)</span>.</li>
</ul>
<p>The idea is to plot the tapering functions for different ranges of <span class="math inline">\(\lambda\)</span> so that the functions are approximately disjoint. When using these <span class="math inline">\(\lambda\)</span>-ranges for calculating the differences of smooths, this will result in orthogonal detail components. For detailed information about the smoother used and the properties of the tapering functions, see <span class="citation">Holmström et al. (2011)</span> and <span class="citation">Schuster (2017)</span>.</p>
<p>The surface air temperature data was simulated on a 120-by-98 grid, and this information has to be passed to the plotting function <code><a href="../reference/TaperingPlot.html">TaperingPlot()</a></code>. The vector <code>lambdaSmoother</code> contains the smoothing levels that should be used for drawing the tapering functions.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of signal-independent tapering functions</span>
<span class="kw"><a href="../reference/TaperingPlot.html">TaperingPlot</a></span>(<span class="dt">lambdaSmoother =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">10000</span>), <span class="dt">mm =</span> <span class="dv">120</span>, <span class="dt">nn =</span> <span class="dv">98</span>)</code></pre></div>

<p>The corresponding tapering functions are shown in Figure . The smoothing levels 0 and <span class="math inline">\(\infty\)</span> are added to the set of smoothing levels, as both of them have a special meaning. Whereas a smoother with <span class="math inline">\(\lambda = 0\)</span> is the so-called identity smoother (<span class="math inline">\(\boldsymbol{S}_{0}\boldsymbol{x} = \boldsymbol{x}\)</span>), smoothing with <span class="math inline">\(\lambda_{L} = \infty\)</span> results in the global mean. The five tapering functions in Figure  are approximately disjoint and a good starting point when trying to find useful smoothing levels.</p>
<p>An even better starting point can be attained if the underlying signal <span class="math inline">\(\boldsymbol{x}\)</span> is also taken into account. <code><a href="../reference/TaperingPlot.html">TaperingPlot()</a></code> allows to draw signal-dependent tapering functions using the (optional) argument <code>Xmu</code>. As the original signal <span class="math inline">\(\boldsymbol{x}\)</span> is unknown, it is replaced by its posterior mean.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of signal-dependent tapering functions</span>
<span class="kw"><a href="../reference/TaperingPlot.html">TaperingPlot</a></span>(<span class="dt">lambdaSmoother =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">100</span>, <span class="dv">10000</span>), 
             <span class="dt">mm =</span> <span class="dv">120</span>, <span class="dt">nn =</span> <span class="dv">98</span>, <span class="dt">Xmu =</span> tas.post.samp<span class="op">$</span>mu)</code></pre></div>

<p>As signal-dependent tapering functions have values that vary wildly, visual inspection of these functions is difficult. <code><a href="../reference/TaperingPlot.html">TaperingPlot()</a></code> therefore uses moving averages on the absolute values of these tapering functions to facilitate visual inspection. Figure  shows that the disjointedness of the smoothed tapering functions is not as pronounced as in Figure , but can still be observed.</p>
<p>A more formal approach is the numerical optimization of a suitable objective function with respect to the smoothing parameters. With <code><a href="../reference/MinLambda.html">MinLambda()</a></code> it is possible to conduct this optimization for 2 or 3 <span class="math inline">\(\lambda\)</span>’s. The resulting smoothing levels are, in terms of disjointedness of the signal-dependent tapering functions, optimal. Still, it is often necessary to adjust the smoothing levels manually. For being able to extract also the smallest-scale details it can for instance be useful to include an additional, small <span class="math inline">\(\lambda\)</span>. Furthermore, the number of “optimal” smoothing levels found with <code><a href="../reference/MinLambda.html">MinLambda()</a></code> is limited. When optimizing over 3 <span class="math inline">\(\lambda\)</span>’s, one ends up with a sequence of 5 smoothing levels in total (3 optimized <span class="math inline">\(\lambda\)</span>’s, <span class="math inline">\(\lambda_{0} = 0\)</span>, <span class="math inline">\(\lambda_{L} = \infty\)</span>). In cases where more smoothing levels are necessary, i.e. where the object contains details relevant on more distinct scales, it is necessary to add smoothing levels manually. However, five smoothing levels turned out to be sufficient in many cases.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Minimization of objective function with respect to the smoothing parameters</span>
tas.min.lambda.out &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MinLambda.html">MinLambda</a></span>(<span class="dt">Xmu =</span> tas.post.samp<span class="op">$</span>mu, <span class="dt">mm =</span> <span class="dv">120</span>, <span class="dt">nn =</span> <span class="dv">98</span>, 
                                <span class="dt">nGrid =</span> <span class="dv">45</span>, <span class="dt">nLambda =</span> <span class="dv">3</span>, <span class="dt">sphere =</span> <span class="ot">FALSE</span>, 
                                <span class="dt">lambda=</span><span class="dv">10</span><span class="op">^</span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">12</span>, <span class="dv">10</span>, <span class="dt">len =</span> <span class="dv">45</span>))</code></pre></div>
<p> </p>
<p>Most of the arguments of <code><a href="../reference/MinLambda.html">MinLambda()</a></code> are already known from <code><a href="../reference/TaperingPlot.html">TaperingPlot()</a></code>. In addition to this, it is necessary to specify <code>nGrid</code> (size of the grid the optimization should be carried out on, nGrid-by-nGrid), <code>nLambda</code> (either 2 or 3, number of <span class="math inline">\(\lambda\)</span>’s to be optimized) and <code>sphere</code> (logical; is the analysis on spherical data?). The optimal <span class="math inline">\(\lambda\)</span> values evaluated for the surface air temperature data are 3.16e-11, 1e+02 and 1e+04.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Minimal smoothing parameter values</span>
tas.min.lambda.out<span class="op">$</span>lambda[tas.min.lambda.out<span class="op">$</span>minind]
<span class="co">#&gt; [1] 3.16e-11 1.00e+02 1.00e+04</span></code></pre></div>
<p> </p>
<p>The minimization result can also be shown visually. For each optimized pair of <span class="math inline">\(\lambda\)</span>’s, a plot is drawn. Figure  shows the optimization for the surface air temperature example. The optimized <span class="math inline">\(\lambda\)</span>’s have the indices <span class="math inline">\(\lambda_{2}\)</span>, <span class="math inline">\(\lambda_{3}\)</span> and <span class="math inline">\(\lambda_{4}\)</span>, because <span class="math inline">\(\lambda_{1} = 0\)</span> and <span class="math inline">\(\lambda_{5} = \infty\)</span>.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of the minimization result</span>
<span class="kw">plot</span>(<span class="dt">x =</span> tas.min.lambda.out)</code></pre></div>


<p>The smoothing levels found with the different methods can now be used as a starting point for finding scale-dependent details in the analyzed object. Usually, a few iterations with some smoothing level adjustments are necessary until the results found are satisfying. For the surface air temperature example, the smoothing level sequence <span class="math inline">\([\lambda_1, \lambda_2, \lambda_3, \lambda_4, \lambda_5] = [0, 0.1, 90, 16'000, \infty]\)</span> turned out to be useful. Using <code><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid()</a></code>, differences of smooths at neighboring scales are created. For the surface air temperature example, the samples generated with <code><a href="../reference/rmvtDCT.html">rmvtDCT()</a></code> are used as input. If other samples are already available and no Bayesian signal reconstruction is needed, it is important to store them as a matrix where each column vector represents one sample.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Creation of differences of smooths at neighboring scales</span>
tas.mrb.out &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid</a></span>(<span class="dt">posteriorFile =</span> tas.post.samp<span class="op">$</span>sample, <span class="dt">mm =</span> <span class="dv">120</span>, <span class="dt">nn =</span> <span class="dv">98</span>, 
                            <span class="dt">lambdaSmoother =</span> <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="dv">90</span>, <span class="dv">15000</span>), <span class="dt">prob =</span> <span class="fl">0.95</span>)</code></pre></div>
<p> </p>
<p>The resulting object <code>tas.mrb.out</code> is a list containing three sublists. <code>smMean</code> contains the mean of each difference of smooths <span class="math inline">\(\boldsymbol{z}_{i}\)</span> over all <code>ns = 1000</code> samples from the posterior <span class="math inline">\(p(\boldsymbol{x}|\boldsymbol{y})\)</span>. The lists <code>hpout</code> and <code>ciout</code> are relevant for the posterior credibility analysis, which is discussed in detail in the next subsection.</p>
<p>The <code>smMean</code>-plots for the surface air temperature example are displayed in Figure . With increasing smoothing level <span class="math inline">\(\lambda\)</span>, the features are getting larger. The first component <span class="math inline">\(\boldsymbol{z}_{1}\)</span> shows the smallest scale details of <span class="math inline">\(\boldsymbol{x}\)</span>. The contours of areas where a rapid change from warmer to colder temperature can be observed are clearly visible. In <span class="math inline">\(\boldsymbol{z}_{2}\)</span>, larger-scale details are identifiable. The Great Lakes seem to be colder than the surrounding regions and the areas surrounding the Gulf of California are clearly warmer than the Gulf itself. <span class="math inline">\(\boldsymbol{z}_{3}\)</span> shows that the Gulf of California is the hottest region in Northern America. Furthermore, the Rocky Mountains are identifiable as a cool, longish band across the map. The next difference of smooths <span class="math inline">\(\boldsymbol{z}_{4}\)</span> shows a north-south temperature gradient, and <span class="math inline">\(\boldsymbol{z}_{5}\)</span> is the mean across the whole map.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Posterior mean of the different detail components</span>
<span class="kw">plot</span>(<span class="dt">x =</span> tas.mrb.out<span class="op">$</span>smMean, <span class="dt">color.pallet =</span> fields<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/fields/topics/tim.colors">tim.colors</a></span>(), <span class="dt">turnOut =</span> <span class="ot">FALSE</span>, 
     <span class="dt">aspRatio =</span> <span class="dv">98</span><span class="op">/</span><span class="dv">120</span>)</code></pre></div>


</div>
<div id="posterior-credibility-analysis" class="section level2">
<h2 class="hasAnchor">
<a href="#posterior-credibility-analysis" class="anchor"></a>Posterior Credibility Analysis</h2>
<p>As the detail components <span class="math inline">\(\boldsymbol{z}_{i}\)</span> are random samples from the posterior distribution <span class="math inline">\(p(\boldsymbol{x}|\boldsymbol{y})\)</span>, a credibility analysis has to be done. The goal is to infer which details are truly there and which are only artifacts of random variation. Three different methods for posterior credibility analysis are implemented in <code>mrbsizeR</code>:</p>
<ul>
<li>
<strong>Pointwise Maps (PW)</strong>: Each location / pixel is tested separately for credibility.</li>
<li>
<strong>Highest Pointwise Probability Maps (HPW)</strong>: The inference is done jointly over all locations. In comparison to PW maps, this results in more non-credible areas. The advantage of HPW maps is that the credible areas are better connected than in PW maps. Small credibility islands with low expressiveness do appear less frequently and simplify the interpretation of the results. </li>
<li>
<strong>Simultaneous Credible Intervals (CI)</strong>: Inference is also done jointly over all locations. Here, simultaneous credible intervals centered on the posterior means are calculated. CI maps flag locations as credible more conservatively than PW or HPW maps.</li>
</ul>
<p>For more detailed information about the three methods, see <span class="citation">Holmström et al. (2011)</span> and <span class="citation">Schuster (2017)</span>. By default, credible regions of all three methods are calculated when executing <code><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid()</a></code>. The corresponding lists in the output of <code><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid()</a></code> are <code>hpout</code> and <code>ciout</code>.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of pointwise (PW) maps</span>
<span class="kw">plot</span>(<span class="dt">x =</span> tas.mrb.out<span class="op">$</span>hpout, <span class="dt">plot_which =</span> <span class="st">"PW"</span>, <span class="dt">aspRatio =</span> <span class="dv">98</span><span class="op">/</span><span class="dv">120</span>,
     <span class="dt">color =</span> <span class="kw">c</span>(<span class="st">"dodgerblue3"</span>, <span class="st">"gainsboro"</span>, <span class="st">"firebrick1"</span>), <span class="dt">turnOut =</span> <span class="ot">FALSE</span>)</code></pre></div>

<p>The pointwise credibility maps in Figure  do show little credibility for the difference of smooths <span class="math inline">\(\boldsymbol{z}_{1}\)</span>. In <span class="math inline">\(\boldsymbol{z}_{2}\)</span>, the Gulf of California is credibly colder than Baja California and the Mexican mainland on the eastern side of the Gulf. In <span class="math inline">\(\boldsymbol{z}_{3}\)</span>, nearly everything is credible. This confirms that the Rocky Mountains are really colder and that the whole area of the Gulf of California is credibly warmer than surrounding regions. With <span class="math inline">\(\boldsymbol{z}_{4}\)</span>, it gets clear that the northern part of the map is credibly colder than the southern part. <span class="math inline">\(\boldsymbol{z}_{5}\)</span> simply shows that the whole global mean is credible.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of highest pointwise probability (HPW) maps</span>
<span class="kw">plot</span>(<span class="dt">x =</span> tas.mrb.out<span class="op">$</span>hpout, <span class="dt">plotWhich =</span> <span class="st">"HPW"</span>, <span class="dt">aspRatio =</span> <span class="dv">98</span><span class="op">/</span><span class="dv">120</span>,
     <span class="dt">color =</span> <span class="kw">c</span>(<span class="st">"dodgerblue3"</span>, <span class="st">"gainsboro"</span>, <span class="st">"firebrick1"</span>), <span class="dt">turnOut =</span> <span class="ot">FALSE</span>)</code></pre></div>

<p>The HPW maps in Figure  exhibit less credibility than the PW maps, especially for small-scale details. However, the interpretation of the results stays the same. Due to the joint inference over all locations, small islands of credibility are less frequent.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of simultaneous credible interval (CI) maps</span>
<span class="kw">plot</span>(<span class="dt">x =</span> tas.mrb.out<span class="op">$</span>ciout, <span class="dt">color =</span> <span class="kw">c</span>(<span class="st">"dodgerblue3"</span>, <span class="st">"gainsboro"</span>, <span class="st">"firebrick1"</span>), 
     <span class="dt">turnOut =</span> <span class="ot">FALSE</span>, <span class="dt">aspRatio =</span> <span class="dv">98</span><span class="op">/</span><span class="dv">120</span>)</code></pre></div>

<p>Detail component <span class="math inline">\(\boldsymbol{z}_{1}\)</span> of the simultaneous credible interval maps in Figure  does not exhibit any credibility. CI maps are generally the most conservative credibility analysis method. It therefore is not surprising that in details <span class="math inline">\(\boldsymbol{z}_{2}\)</span> and <span class="math inline">\(\boldsymbol{z}_{3}\)</span> more gray areas can be observed than in the PW or HPW maps (compare Figures  and ). Still, especially for the larger-scale details, the interpretation of the results does not change.</p>

</div>
</div>
<div id="example-comparison-to-matlab-software" class="section level1">
<h1 class="hasAnchor">
<a href="#example-comparison-to-matlab-software" class="anchor"></a>Example: Comparison to Matlab software</h1>
<p>The <code>mrbsizeR</code> methodology was first implemented in the Matlab program MRBSiZer , which is available at <a href="http://cc.oulu.fi/~lpasanen/MRBSiZer/" class="uri">http://cc.oulu.fi/~lpasanen/MRBSiZer/</a>. In order to ensure that the results obtained with R and Matlab are concordant, the sketch pad example from the original paper  is reconstructed (compare Figure . The digital image is of the size 284-by-400 and the prior parameters <span class="math inline">\(\lambda_{0}\)</span>, <span class="math inline">\(\sigma_{0}^{2}\)</span> and <span class="math inline">\(\nu_{0}\)</span> had the values <span class="math inline">\(0.2, 8.9^2\)</span> and <span class="math inline">\(10\)</span>, respectively. The set of smoothing levels used in the multiresolution analysis was <span class="math inline">\([0, 1, 30, 6 \times 10^5, \infty]\)</span>. 3000 samples of the posterior <span class="math inline">\(p(\boldsymbol{x}|\boldsymbol{y})\)</span> were generated.</p>


<p>The detail components <span class="math inline">\(\boldsymbol{z}_{i}\)</span> are shown in Figure . As the output of <code><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid()</a></code> is based on random samples, small differences between two executions are inevitable. When compared to the Matlab figures in <span class="citation">Holmström et al. (2011)</span>, no big differences can be detected. More differences can be found in the HPW maps, especially in detail component <span class="math inline">\(\boldsymbol{z}_{3}\)</span> (compare Figure ). It seems that in the <strong>R</strong> implementation, a slightly larger part of the component was flagged as credible. Nevertheless, the detail components look very similar to their Matlab pendants and the interpretation of the results stays the same. The differences can be explained by random sampling and one can be confident that concordance across the systems holds.</p>


</div>
<div id="example-data-on-a-sphere" class="section level1">
<h1 class="hasAnchor">
<a href="#example-data-on-a-sphere" class="anchor"></a>Example: Data On A Sphere</h1>
<p>The third example in this vignette demonstrates how <code>mrbsizeR</code> can be used to analyze spherical data. In contrast to the analysis of data on a grid, no Bayesian signal reconstruction is implemented. To form scale-dependent details, data samples need to be available beforehand. The analysis procedure for spherical data can therefore be summarized in two steps:</p>

<p>Data from the Community Climate System Model 4.0 (CCSM4, see <a href="http://www.cesm.ucar.edu/models/ccsm4.0/ccsm/" class="uri">http://www.cesm.ucar.edu/models/ccsm4.0/ccsm/</a>) is used to illustrate <code>mrbsizeR</code> on spherical data. CCSM4 is a climate model simulating the earth’s climate system, see <span class="citation">Gent et al. (2011)</span>. For this analysis, the simulated surface air temperature in June of the years 1870–2100 was considered. Instead of using the surface air temperature itself, its deviation to the yearly mean has been used. This detrends the data and makes the simulations of 231 consecutive years comparable. The resulting data set consisting of 231 observations is then used as samples for the <code>mrbsizeR</code> analysis. The data is not part of the <code>mrbsizeR</code> package.</p>
<p>Figure  summarizes the samples by their mean. It is clearly visible that the temperature is higher in areas around the equator and gets lower closer to the Polar Regions. The unit of the surface air temperature deviation is degrees Kelvin.</p>
<div class="figure" style="text-align: center">
<img src="mrbsizeR_files/figure-html/spherical1-1.png" alt="\label{fig:spherical1}Deviation from mean of simulated air temperature measurements (CCSM4) for the years 1870--2100 in degrees Kelvin. The deviations are summarized by their mean." width="480"><p class="caption">
Deviation from mean of simulated air temperature measurements (CCSM4) for the years 1870–2100 in degrees Kelvin. The deviations are summarized by their mean.
</p>
</div>

<p>For conducting scale space multiresolution analysis with <code>mrbsizeR</code>, useful smoothing parameters need to be evaluated first. As explained in the NARCCAP data example, <code><a href="../reference/MinLambda.html">MinLambda()</a></code> offers the possibility to find useful smoothing parameters numerically. The function call for spherical data is nearly identical to the call for non-spherical data, the only difference is the argument <code>sphere</code> which has to be <code>TRUE</code>.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Minimization of objective function with respect to the smoothing parameters</span>
<span class="co"># for spherical data</span>
spherical.min.lambda.out &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MinLambda.html">MinLambda</a></span>(<span class="dt">Xmu =</span> dat.ccsm4.mu, <span class="dt">mm =</span> <span class="dv">144</span>, <span class="dt">nn =</span> <span class="dv">72</span>, 
                                      <span class="dt">nGrid =</span> <span class="dv">35</span>, <span class="dt">nLambda =</span> <span class="dv">2</span>, <span class="dt">sphere =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p> </p>
<p>Once useful smoothing levels have been selected, differences of smooths at neighboring scales can be created using the function <code><a href="../reference/mrbsizeRsphere.html">mrbsizeRsphere()</a></code>.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Creation of differences of smooths at neighboring scales for spherical data</span>
spherical.mrb.out &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mrbsizeRsphere.html">mrbsizeRsphere</a></span>(<span class="dt">posteriorFile =</span> dat.ccsm4, <span class="dt">mm =</span> <span class="dv">144</span>, <span class="dt">nn =</span> <span class="dv">72</span>,
                                    <span class="dt">prob =</span> <span class="fl">0.95</span>, <span class="dt">lambdaSmoother =</span> <span class="kw">c</span>(<span class="fl">0.0026</span>))</code></pre></div>
<p> </p>
<p>For creating the differences of smooths at neighboring scales in Figure , the smoothing level sequence <span class="math inline">\([\lambda_{1}, \dots, \lambda_{3}] = [0, 0.0026, \infty]\)</span> was used. Only one smoothing level was added to the default sequence <span class="math inline">\([0, \infty]\)</span>. This is enough to capture features at all different scales. Whereas <span class="math inline">\(\boldsymbol{z}_{1}\)</span> shows small-scale details like colder regions in Tibet or Chile, <span class="math inline">\(\boldsymbol{z}_{2}\)</span> reveals a large red-colored area around the equator and large blue-colored areas at the Polar Regions. <span class="math inline">\(\boldsymbol{z}_{3}\)</span> shows the global mean.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Posterior mean of the different detail components for spherical data</span>
<span class="kw">plot</span>(<span class="dt">x =</span> spherical.mrb.out<span class="op">$</span>smMean, <span class="dt">lon =</span> dat.ccsm4<span class="op">$</span>lon, <span class="dt">lat =</span> dat.ccsm4<span class="op">$</span>lat,
     <span class="dt">color.pallet =</span> fields<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/fields/topics/tim.colors">tim.colors</a></span>())</code></pre></div>


<p>The posterior credibility analysis of detail component <span class="math inline">\(\boldsymbol{z}_{1}\)</span> using highest pointwise probability (HPW) maps (compare Figure ) reveals that regions like Chile or the eastern part of South Africa are credibly colder than surrounding areas. The large-scale components in <span class="math inline">\(\boldsymbol{z}_{2}\)</span> are mostly credible and hence “really there”. The global mean in <span class="math inline">\(\boldsymbol{z}_{3}\)</span> is not credible in this example. The reason is the data used: Instead of considering the yearly surface air temperature, its deviations to the yearly mean are considered. <span class="math inline">\(\boldsymbol{z}_{3}\)</span> is therefore not the average surface air temperature, but the average mean deviation, which always equals 0.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Plot of highest pointwise probability (HPW) maps for spherical data</span>
<span class="kw">plot</span>(<span class="dt">x =</span> spherical.mrb.out<span class="op">$</span>hpout, <span class="dt">lon =</span> dat.ccsm4<span class="op">$</span>lon, <span class="dt">lat =</span> dat.ccsm4<span class="op">$</span>lat,    
     <span class="dt">plotWhich =</span> <span class="st">"HPW"</span>, <span class="dt">color =</span> <span class="kw">c</span>(<span class="st">"dodgerblue3"</span>, <span class="st">"gainsboro"</span>, <span class="st">"firebrick1"</span>))</code></pre></div>


</div>
<div id="what-if-not-enough-computing-power-is-available" class="section level1">
<h1 class="hasAnchor">
<a href="#what-if-not-enough-computing-power-is-available" class="anchor"></a>What If Not Enough Computing Power Is Available?</h1>
<p>Especially for analyses with a large analysis object and/or many samples, an <code>mrbsizeR</code> analysis is resource-intensive. For cases where due to computational reasons not enough samples can be generated, the additional argument <code>smoothOut</code> has been added to <code><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid()</a></code> and <code><a href="../reference/mrbsizeRsphere.html">mrbsizeRsphere()</a></code>. If <code>smoothOut = TRUE</code>, the output list will also contain a sublist <code>smoothSamples</code>, which includes the differences of smooths for all samples. This makes it possible to manually increase the number of samples and get HPW maps and CI maps with a higher confidence. An example is provided in the following code chunk.</p>
<p> </p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Generate samples from posterior distribution</span>
tas.post.samp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rmvtDCT.html">rmvtDCT</a></span>(<span class="dt">object =</span> tas.su.<span class="fl">1995.</span>MM5I<span class="op">$</span>su, 
                         <span class="dt">lambda =</span> <span class="fl">0.2</span>, <span class="dt">sigma =</span> <span class="dv">36</span>, <span class="dt">nu0 =</span> <span class="dv">15</span>, <span class="dt">ns =</span> <span class="dv">1000</span>)

<span class="co"># Do mrbsizeR analysis and output the differences of smooths for all samples</span>
tas.mrb.out.<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid</a></span>(<span class="dt">posteriorFile =</span> tas.post.samp<span class="op">$</span>sample, <span class="dt">mm =</span> <span class="dv">120</span>, 
                              <span class="dt">nn =</span> <span class="dv">98</span>, <span class="dt">lambdaSmoother =</span> <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="dv">90</span>, <span class="dv">15000</span>),
                              <span class="dt">prob =</span> <span class="fl">0.95</span>, <span class="dt">smoothOut =</span> <span class="ot">TRUE</span>)

<span class="co"># Do the same procedure again</span>
tas.post.samp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rmvtDCT.html">rmvtDCT</a></span>(<span class="dt">object =</span> tas.su.<span class="fl">1995.</span>MM5I<span class="op">$</span>su, 
                         <span class="dt">lambda =</span> <span class="fl">0.2</span>, <span class="dt">sigma =</span> <span class="dv">36</span>, <span class="dt">nu0 =</span> <span class="dv">15</span>, <span class="dt">ns =</span> <span class="dv">1000</span>)

tas.mrb.out.<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mrbsizeRgrid.html">mrbsizeRgrid</a></span>(<span class="dt">posteriorFile =</span> tas.post.samp<span class="op">$</span>sample, <span class="dt">mm =</span> <span class="dv">120</span>, 
                              <span class="dt">nn =</span> <span class="dv">98</span>, <span class="dt">lambdaSmoother =</span> <span class="kw">c</span>(<span class="fl">0.1</span>, <span class="dv">90</span>, <span class="dv">15000</span>), 
                              <span class="dt">prob =</span> <span class="fl">0.95</span>, <span class="dt">smoothOut =</span> <span class="ot">TRUE</span>)

<span class="co"># Combine all differences-of-smooths-samples and call CImap manually</span>
smoothSamples &lt;-<span class="st"> </span><span class="kw">list</span>(); ciout &lt;-<span class="st"> </span><span class="kw">list</span>()

<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(tas.mrb.out.<span class="dv">1</span><span class="op">$</span>smoothSamples)) {
  smoothSamples &lt;-<span class="st"> </span><span class="kw">cbind</span>(tas.mrb.out.<span class="dv">1</span><span class="op">$</span>smoothSamples[[i]], 
                         tas.mrb.out.<span class="dv">2</span><span class="op">$</span>smoothSamples[[i]])
  ciout[[i]] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/CImap.html">CImap</a></span>(<span class="dt">smoothVec =</span> smoothSamples, <span class="dt">mm =</span> <span class="dv">120</span>, <span class="dt">nn =</span> <span class="dv">98</span>, <span class="dt">prob =</span> <span class="fl">0.95</span>)
}

<span class="co"># Set the class correctly for visualizing the output.</span>
<span class="co"># Titles need to be defined in this case!</span>
<span class="co"># Class name CI maps: "CImapGrid" or "CImapSphere"</span>
<span class="co"># Class name PW / HPW maps: "HPWmapGrid" or "HPWmapSphere"</span>
<span class="kw">class</span>(ciout) &lt;-<span class="st"> "CImapGrid"</span>
<span class="kw">plot</span>(ciout, <span class="dt">title =</span> <span class="kw">c</span>(<span class="st">"Diff_1"</span>, <span class="st">"Diff_2"</span>, <span class="st">"Diff_3"</span>, <span class="st">"Diff_4"</span>, <span class="st">"Diff_5"</span>))</code></pre></div>

</div>
<div id="data-acknowledgments" class="section level1">
<h1 class="hasAnchor">
<a href="#data-acknowledgments" class="anchor"></a>Data Acknowledgments</h1>
<p>We wish to thank the North American Regional Climate Change Assessment Program (NARCCAP) for providing the data used in this paper. NARCCAP is funded by the National Science Foundation (NSF), the U.S. Department of Energy (DoE), the National Oceanic and Atmospheric Administration (NOAA), and the U.S. Environmental Protection Agency Office of Research and Development (EPA).</p>
<p>We acknowledge the World Climate Research Program’s Working Group on Coupled Modelling, which is responsible for CMIP, and we thank the climate modeling groups for producing and making available their model output. For CMIP the U.S. Department of Energy’s Program for Climate Model Diagnosis and Intercomparison provides coordinating support and led development of software infrastructure in partnership with the Global Organization for Earth System Science Portals.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-erasto2005">
<p>Erästö, Panu, and Lasse Holmström. 2005. “Bayesian Multiscale Smoothing for Making Inferences About Features in Scatterplots.” <em>Journal of Computational and Graphical Statistics</em> 14 (3): 569–89.</p>
</div>
<div id="ref-gent2011">
<p>Gent, Peter R., Gokhan Danabasoglu, Leo J. Donner, Marika M. Holland, Elizabeth C. Hunke, Steve R. Jayne, David M. Lawrence, et al. 2011. “The Community Climate System Model Version 4.” <em>Journal of Climate</em> 24: 4973–91.</p>
</div>
<div id="ref-holmstrom2016">
<p>Holmström, Lasse, and Leena Pasanen. 2016. “Statistical Scale Space Methods.” <em>International Statistical Review</em>.</p>
</div>
<div id="ref-holmstrom2011">
<p>Holmström, Lasse, Leena Pasanen, Reinhard Furrer, and Stephan R. Sain. 2011. “Scale Space Multiresolution Analysis of Random Signals.” <em>Computational Statistics and Data Analysis</em> 55: 2840–55.</p>
</div>
<div id="ref-lindeberg1994">
<p>Lindeberg, Tony. 1994. “Scale-Space Theory: A Basic Tool for Analysing Structures at Different Scales.” <em>Journal of Applied Statistics</em> 21 (2): 225–70.</p>
</div>
<div id="ref-schuster2017">
<p>Schuster, Thimo. 2017. “mrbsizeR: Scale Space Multiresolution Analysis in R.” Master’s thesis, University of Zurich.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li>
<a href="#example-data-on-a-regular-grid">Example: Data On A Regular Grid</a><ul class="nav nav-pills nav-stacked">
<li><a href="#bayesian-signal-reconstruction">Bayesian Signal Reconstruction</a></li>
      <li><a href="#forming-of-scale-dependent-detail-components">Forming of scale-dependent detail components</a></li>
      <li><a href="#posterior-credibility-analysis">Posterior Credibility Analysis</a></li>
      </ul>
</li>
      <li><a href="#example-comparison-to-matlab-software">Example: Comparison to Matlab software</a></li>
      <li><a href="#example-data-on-a-sphere">Example: Data On A Sphere</a></li>
      <li><a href="#what-if-not-enough-computing-power-is-available">What If Not Enough Computing Power Is Available?</a></li>
      <li><a href="#data-acknowledgments">Data Acknowledgments</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Thimo Schuster, Roman Flury.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
